<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /* 
            垃圾回收算法
                - GC标记-清除法
                    

                - GC引用计数法
                    - 通过计数器来表示对象的引用数量，当计数器为0的时候，垃圾立刻被回收
                    - 优点：立刻回收
                    - 缺点：计数器占位、如果出现循环引用的时候无法清除

                - 代码的内存优化
                    - 减少使用全局变量
                    - 减少使用闭包
                    - 对象的共有方法添加到原型对象中
                    - 使用字面量声明数组或对象
                    - 减少属性的读取次数（比如和oLis.length书写在for的外边）
                    - 减少if的判断层级，通过return退出，而不是else
                    - 减少作用域链的查找层级
                    - 事件委托
                    - 使用碎片节点

        */

        function fn() {
            var o1 = {}; //o1对象 被o1引用 计数器是1
            var o2 = {}; //o2对象 被o2引用 计数器是1

            o1.a = o2; // o2对象 被o1的a属性引用 计数器是2
            o2.a = o1; // o1对象 被o2的a属性引用 计数器是2

            //函数运行结束 所有对象的引用计数器减1，此时o1和o2仍然不能被回收
        }
    </script>
</body>

</html>